/*!
 * VERSION: 0.2.0
 * DATE: 2015-09-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * MorphSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
 * This work is subject to the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
const _gsScope = typeof module !== 'undefined' && module.exports && typeof global !== 'undefined' ? global : this || window; (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(() => {
  const a = Math.PI / 180; const b = 180 / Math.PI; const c = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi; const d = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi; const e = /[achlmqstvz]/gi; const f = _gsScope.TweenLite; const g = function (a) { window.console && console.log(a); }; const h = function (b, c) { let d; let e; let f; let g; let h; let i; const j = Math.ceil(Math.abs(c) / 90); let k = 0; const l = []; for (b *= a, c *= a, d = c / j, e = 4 / 3 * Math.sin(d / 2) / (1 + Math.cos(d / 2)), i = 0; j > i; i++)f = b + i * d, g = Math.cos(f), h = Math.sin(f), l[k++] = g - e * h, l[k++] = h + e * g, f += d, g = Math.cos(f), h = Math.sin(f), l[k++] = g + e * h, l[k++] = h - e * g, l[k++] = g, l[k++] = h; return l; }; const i = function (c, d, e, f, g, i, j, k, l) { if (c !== k || d !== l) { e = Math.abs(e), f = Math.abs(f); const m = g % 360 * a; const n = Math.cos(m); const o = Math.sin(m); const p = (c - k) / 2; const q = (d - l) / 2; const r = n * p + o * q; const s = -o * p + n * q; let t = e * e; let u = f * f; const v = r * r; const w = s * s; const x = v / t + w / u; x > 1 && (e = Math.sqrt(x) * e, f = Math.sqrt(x) * f, t = e * e, u = f * f); let y = i === j ? -1 : 1; let z = (t * u - t * w - u * v) / (t * w + u * v); z < 0 && (z = 0); const A = y * Math.sqrt(z); const B = A * (e * s / f); const C = A * -(f * r / e); const D = (c + k) / 2; const E = (d + l) / 2; const F = D + (n * B - o * C); const G = E + (o * B + n * C); const H = (r - B) / e; const I = (s - C) / f; const J = (-r - B) / e; const K = (-s - C) / f; let L = Math.sqrt(H * H + I * I); let M = H; y = I < 0 ? -1 : 1; let N = y * Math.acos(M / L) * b; L = Math.sqrt((H * H + I * I) * (J * J + K * K)), M = H * J + I * K, y = H * K - I * J < 0 ? -1 : 1; let O = y * Math.acos(M / L) * b; !j && O > 0 ? O -= 360 : j && O < 0 && (O += 360), O %= 360, N %= 360; let P; let Q; let R; const S = h(N, O); const T = n * e; const U = o * e; const V = o * -f; const W = n * f; const X = S.length - 2; for (P = 0; X > P; P += 2)Q = S[P], R = S[P + 1], S[P] = Q * T + R * V + F, S[P + 1] = Q * U + R * W + G; return S[S.length - 2] = k, S[S.length - 1] = l, S; } }; const j = function (a) { let b; let d; let e; let f; let h; let j; let k; let l; let m; let n; let o; let p; let q; const r = (`${a}`).match(c) || []; const s = []; let t = 0; let u = 0; const v = r.length; let w = 2; let x = 0; if (!a || !isNaN(r[0]) || isNaN(r[1])) return g(`ERROR: malformed path data: ${a}`), s; for (b = 0; v > b; b++) if (q = h, isNaN(r[b]) ? (h = r[b].toUpperCase(), j = h !== r[b]) : b--, e = +r[b + 1], f = +r[b + 2], j && (e += t, f += u), b === 0 && (l = e, m = f), h === 'M')t = e, u = f, k = [e, f], x += w, w = 2, s.push(k), b += 2; else if (h === 'C')k || (k = [0, 0]), k[w++] = e, k[w++] = f, j || (t = u = 0), k[w++] = t + 1 * r[b + 3], k[w++] = u + 1 * r[b + 4], k[w++] = t += 1 * r[b + 5], k[w++] = u += 1 * r[b + 6], b += 6; else if (h === 'S')q === 'C' || q === 'S' ? (n = t - k[w - 4], o = u - k[w - 3], k[w++] = t + n, k[w++] = u + o) : (k[w++] = t, k[w++] = u), k[w++] = e, k[w++] = f, j || (t = u = 0), k[w++] = t += 1 * r[b + 3], k[w++] = u += 1 * r[b + 4], b += 4; else if (h === 'Q')n = e - t, o = f - u, k[w++] = t + 2 * n / 3, k[w++] = u + 2 * o / 3, j || (t = u = 0), t += 1 * r[b + 3], u += 1 * r[b + 4], n = e - t, o = f - u, k[w++] = t + 2 * n / 3, k[w++] = u + 2 * o / 3, k[w++] = t, k[w++] = u, b += 4; else if (h === 'T')n = t - k[w - 4], o = u - k[w - 3], k[w++] = t + n, k[w++] = u + o, n = t + 1.5 * n - e, o = u + 1.5 * o - f, k[w++] = e + 2 * n / 3, k[w++] = f + 2 * o / 3, k[w++] = t = e, k[w++] = u = f, b += 2; else if (h === 'H')f = u, k[w++] = t + (e - t) / 3, k[w++] = u + (f - u) / 3, k[w++] = t + 2 * (e - t) / 3, k[w++] = u + 2 * (f - u) / 3, k[w++] = t = e, k[w++] = f, b += 1; else if (h === 'V')f = e, e = t, j && (f += u - t), k[w++] = e, k[w++] = u + (f - u) / 3, k[w++] = e, k[w++] = u + 2 * (f - u) / 3, k[w++] = e, k[w++] = u = f, b += 1; else if (h === 'L')k[w++] = t + (e - t) / 3, k[w++] = u + (f - u) / 3, k[w++] = t + 2 * (e - t) / 3, k[w++] = u + 2 * (f - u) / 3, k[w++] = t = e, k[w++] = u = f, b += 2; else if (h === 'Z')t = l, u = m; else if (h === 'A') { for (p = i(t, u, 1 * r[b + 1], 1 * r[b + 2], 1 * r[b + 3], 1 * r[b + 4], 1 * r[b + 5], (j ? t : 0) + 1 * r[b + 6], (j ? u : 0) + 1 * r[b + 7]), d = 0; d < p.length; d++)k[w++] = p[d]; t = k[w - 2], u = k[w - 1], b += 7; } else g(`Error: malformed path data: ${a}`); return s.totalPoints = x + w, s; }; const k = function (a, b) { let c; let d; let e; let f; let g; let h; let i; let j; let k; let l; let m; let n; let o; let p; let q = 0; const r = 0.999999; let s = a.length; const t = b / ((s - 2) / 6); for (o = 2; s > o; o += 6) for (q += t; q > r;)c = a[o - 2], d = a[o - 1], e = a[o], f = a[o + 1], g = a[o + 2], h = a[o + 3], i = a[o + 4], j = a[o + 5], p = 1 / (Math.floor(q) + 1), k = c + (e - c) * p, m = e + (g - e) * p, k += (m - k) * p, m += (g + (i - g) * p - m) * p, l = d + (f - d) * p, n = f + (h - f) * p, l += (n - l) * p, n += (h + (j - h) * p - n) * p, a.splice(o, 4, c + (e - c) * p, d + (f - d) * p, k, l, k + (m - k) * p, l + (n - l) * p, m, n, g + (i - g) * p, h + (j - h) * p), o += 6, s += 6, q--; return a; }; const l = function (a) { let b; let c; let d; let e; let f = ''; const g = a.length; const h = 100; for (c = 0; g > c; c++) for (e = a[c], f += `M${e[0]},${e[1]} C`, b = e.length, d = 2; b > d; d++)f += `${(e[d++] * h | 0) / h},${(e[d++] * h | 0) / h} ${(e[d++] * h | 0) / h},${(e[d++] * h | 0) / h} ${(e[d++] * h | 0) / h},${(e[d] * h | 0) / h} `; return f; }; const m = function (a, b) { return b.length - a.length; }; const n = function (a) { for (var b = [], c = a.length - 1, d = 0; --c > -1;)b[d++] = a[c], b[d++] = a[c + 1], c--; for (c = 0; d > c; c++)a[c] = b[c]; a.reversed = a.reversed ? !1 : !0; }; const o = function (a, b) { let c; let d; const e = a.slice(0); const f = a.length; const g = f - 2; for (b = 0 | b, c = 0; f > c; c++)d = (c + b) % g, a[c++] = e[d], a[c] = e[d + 1]; }; const p = function (a, b, c) { let d; let e; const f = a.length; let g = 0; const h = f - 2; for (c *= 6, e = 0; f > e; e += 6)d = (e + c) % h, g += Math.abs(a[d] - b[e]) + Math.abs(a[d + 1] - b[e + 1]); return g; }; const q = function (a, b, c) { let d; let e; let f; const g = a.length; let h = p(a, b, 0); let i = 0; for (f = 6; g > f; f += 6)e = p(a, b, f / 6), h > e && (h = e, i = f); if (c) for (d = a.slice(0), n(d), f = 6; g > f; f += 6)e = p(d, b, f / 6), h > e && (h = e, i = -f); return i / 6; }; const r = function (a, b, c) { let d; let e; const f = a.length; let g = 99999999999; let h = 0; for (e = 0; f > e; e += 6)d = Math.abs(a[e] - b) + Math.abs(a[e + 1] - c), g > d && (g = d, h = e); return h; }; const s = function (a, b, c) { let d; let e; let f; let g; let h; let i = b.length - a.length; const j = i > 0 ? b : a; const l = i > 0 ? a : b; let p = 0; let s = l.length; const t = typeof c === 'object' && c.push ? c.slice(0) : [c]; let u = t[0] === 'reverse' || t[0] < 0; if (i) for (i < 0 && (i = -i), a.sort(m), b.sort(m), j[0].length > l[0].length && k(l[0], (j[0].length - l[0].length) / 6 | 0); i > p;)f = r(l[0], j[s][0], j[s][1]), g = l[0][f], h = l[0][f + 1], l[s++] = [g, h, g, h, g, h, g, h], l.totalPoints += 8, p++; for (s = 0; s < a.length; s++)d = b[s], e = a[s], i = d.length - e.length, i < 0 ? k(d, -i / 6 | 0) : i > 0 && k(e, i / 6 | 0), u && !e.reversed && n(e), c = t[s] || t[s] === 0 ? t[s] : 'auto', c && (Math.abs(e[0] - e[e.length - 2]) < 0.01 && Math.abs(e[1] - e[e.length - 1]) < 0.01 ? c === 'auto' ? (t[s] = c = q(e, d, s === 0), c < 0 && (u = !0, n(e), c = -c), o(e, 6 * c)) : c !== 'reverse' && o(e, 6 * (c < 0 ? -c : c)) : !u && (c === 'auto' && Math.abs(d[0] - e[0]) + Math.abs(d[1] - e[1]) + Math.abs(d[d.length - 2] - e[e.length - 2]) + Math.abs(d[d.length - 1] - e[e.length - 1]) > Math.abs(d[0] - e[e.length - 2]) + Math.abs(d[1] - e[e.length - 1]) + Math.abs(d[d.length - 2] - e[0]) + Math.abs(d[d.length - 1] - e[1]) || c % 2) ? (n(e), t[s] = -1, u = !0) : c === 'auto' ? t[s] = 0 : c === 'reverse' && (t[s] = -1)); return t; }; const t = function (a, b) { const c = j(a[0]); const d = j(a[1]); s(c, d, b || b === 0 ? b : 'auto'), a[0] = l(c), a[1] = l(d); }; const u = function (a) { return a || a === 0 ? function (b) { t(b, a); } : t; }; const v = function (a, b) { if (!b) return a; let c; let e; let f; const g = a.match(d) || []; const h = g.length; let i = ''; for (b === 'reverse' ? (e = h - 1, c = -2) : (e = (2 * (parseInt(b, 10) || 0) + 1 + 100 * h) % h, c = 2), f = 0; h > f; f += 2)i += `${g[e - 1]},${g[e]} `, e = (e + c) % h; return i; }; const w = function (a, b) { let c; let d; let e; let f; let g; let h; let i; let j = 0; let k = parseFloat(a[0]); let l = parseFloat(a[1]); let m = `${k},${l} `; const n = 0.999999; for (e = a.length, c = 0.5 * b / (0.5 * e - 1), d = 0; e - 2 > d; d += 2) { if (j += c, h = parseFloat(a[d + 2]), i = parseFloat(a[d + 3]), j > n) for (g = 1 / (Math.floor(j) + 1), f = 1; j > n;)m += `${(k + (h - k) * g * f).toFixed(2)},${(l + (i - l) * g * f).toFixed(2)} `, j--, f++; m += `${h},${i} `, k = h, l = i; } return m; }; const x = function (a) { const b = a[0].match(d) || []; const c = a[1].match(d) || []; const e = c.length - b.length; e > 0 ? a[0] = w(b, e) : a[1] = w(c, -e); }; const y = function (a) { return isNaN(a) ? x : function (b) { x(b), b[1] = v(b[1], parseInt(a, 10)); }; }; const z = function (a, b) { const c = document.createElementNS('http://www.w3.org/2000/svg', 'path'); const d = Array.prototype.slice.call(a.attributes); let e = d.length; for (b = `,${b},`; --e > -1;)b.indexOf(`,${d[e].nodeName},`) === -1 && c.setAttributeNS(null, d[e].nodeName, d[e].nodeValue); return c; }; const A = function (a, b) { let c; let e; let f; let g; let h; let i; let j; let k; let l; let m; let n; let o; let p; let q; let r; let s; let t; let u; let v; let w; let x; const y = a.tagName.toLowerCase(); const A = 0.552284749831; return y !== 'path' && a.getBBox ? (i = z(a, 'x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points'), y === 'rect' ? (g = +a.getAttribute('rx') || 0, h = +a.getAttribute('ry') || 0, e = +a.getAttribute('x') || 0, f = +a.getAttribute('y') || 0, m = (+a.getAttribute('width') || 0) - 2 * g, n = (+a.getAttribute('height') || 0) - 2 * h, g || h ? (o = e + g * (1 - A), p = e + g, q = p + m, r = q + g * A, s = q + g, t = f + h * (1 - A), u = f + h, v = u + n, w = v + h * A, x = v + h, c = `M${s},${u} V${v} C${[s, w, r, x, q, x, q - (q - p) / 3, x, p + (q - p) / 3, x, p, x, o, x, e, w, e, v, e, v - (v - u) / 3, e, u + (v - u) / 3, e, u, e, t, o, f, p, f, p + (q - p) / 3, f, q - (q - p) / 3, f, q, f, r, f, s, t, s, u].join(',')}`) : c = `M${e + m},${f} v${n} h${-m} v${-n} h${m}z`) : y === 'circle' || y === 'ellipse' ? (y === 'circle' ? (g = h = +a.getAttribute('r') || 0, k = g * A) : (g = +a.getAttribute('rx') || 0, h = +a.getAttribute('ry') || 0, k = h * A), e = +a.getAttribute('cx') || 0, f = +a.getAttribute('cy') || 0, j = g * A, c = `M${e + g},${f} C${[e + g, f + k, e + j, f + h, e, f + h, e - j, f + h, e - g, f + k, e - g, f, e - g, f - k, e - j, f - h, e, f - h, e + j, f - h, e + g, f - k, e + g, f].join(',')}`) : y === 'line' ? c = `M${a.getAttribute('x1')},${a.getAttribute('y1')} L${a.getAttribute('x2')},${a.getAttribute('y2')}` : (y === 'polyline' || y === 'polygon') && (l = (`${a.getAttribute('points')}`).match(d) || [], e = l.shift(), f = l.shift(), c = `M${e},${f} L${l.join(',')}`, y === 'polygon' && (c += `,${e},${f}`)), i.setAttribute('d', c), b && a.parentNode && (a.parentNode.insertBefore(i, a), a.parentNode.removeChild(a)), i) : a; }; const B = function (a, b) { let c; let e; return (typeof a !== 'string' || (a.match(d) || []).length < 3) && (c = f.selector(a), c && c[0] ? (c = c[0], e = c.nodeName.toUpperCase(), b && e !== 'PATH' && (c = A(c, !1), e = 'PATH'), a = c.getAttribute(e === 'PATH' ? 'd' : 'points') || '') : g(`WARNING: invalid morph to: ${a}`)), a; }; const C = 'Use MorphSVGPlugin.convertToPath(elementOrSelectorText) to convert to a path before morphing.'; const D = _gsScope._gsDefine.plugin({
    propName: 'morphSVG', API: 2, global: !0, version: '0.2.0', init(a, b, c) { let d; let f; let h; let i; let j; return typeof a.setAttribute !== 'function' ? !1 : (d = a.nodeName.toUpperCase(), j = d === 'POLYLINE' || d === 'POLYGON', d === 'PATH' || j ? (f = d === 'PATH' ? 'd' : 'points', (typeof b === 'string' || b.getBBox) && (b = { shape: b }), i = B(b.shape || b.d || b.points || '', f === 'd'), j && e.test(i) ? (g(`WARNING: a <${d}> cannot accept path data. ${C}`), !1) : (this._target = a, h = this._addTween(a, 'setAttribute', `${a.getAttribute(f)}`, `${i}`, 'morphSVG', !1, f, f === 'd' ? u(b.shapeIndex) : y(b.shapeIndex)), h && (this._overwriteProps.push('morphSVG'), h.end = i, h.endProp = f), !0)) : (g(`WARNING: cannot morph a <${d}> SVG element. ${C}`), !1)); }, set(a) { let b; if (this._super.setRatio.call(this, a), a === 1) for (b = this._firstPT; b;)b.end && this._target.setAttribute(b.endProp, b.end), b = b._next; },
  }); D.pathFilter = t, D.pointsFilter = x, D.subdivideRawBezier = k, D.pathDataToRawBezier = function (a) { return j(B(a, !0)); }, D.equalizeSegmentQuantity = s, D.convertToPath = function (a, b) { typeof a === 'string' && (a = f.selector(a)); for (var c = a && a.length !== 0 ? a.length && a[0] && a[0].nodeType ? a : [a] : [], d = c.length; --d > -1;)c[d] = A(c[d], b !== !1); return c; }, D.pathDataToBezier = function (a, b) { let c; let d; let e; let f; let g; let h; const i = j(B(a, !0))[0] || []; if (b = b || {}, f = b.matrix, c = [], e = i.length, f) for (b.relative && (f = f.slice(0), f[4] -= i[0], f[5] -= i[1]), d = 0; e > d; d += 2)c.push({ x: i[d] * f[0] + i[d + 1] * f[2] + f[4], y: i[d] * f[1] + i[d + 1] * f[3] + f[5] }); else for (g = b.offsetX || 0, h = b.offsetY || 0, b.relative && (g -= i[0], h -= i[1]), d = 0; e > d; d += 2)c.push({ x: i[d] + g, y: i[d + 1] + h }); return c; };
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()();
